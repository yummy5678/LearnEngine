#include "StagingImageBuffer.h"



VStagingImageBuffer::VStagingImageBuffer() :
	VBufferBase(
		vk::BufferUsageFlagBits::eTransferSrc | // このバッファはコピー元として利用する
		vk::BufferUsageFlagBits::eTransferDst , // このバッファはメモリ転送先として利用できる
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |	//CPUからアクセス可能
		VK_MEMORY_PROPERTY_HOST_COHERENT_BIT|
		VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
		NULL,
		VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
		VMA_ALLOCATION_CREATE_MAPPED_BIT),
	m_LogicalDevice(VK_NULL_HANDLE),
	m_PhysicalDevice(VK_NULL_HANDLE),
	m_CommandBuffer(VK_NULL_HANDLE),
	m_CommandPool(VK_NULL_HANDLE),
	m_ImageWidth(0),
	m_ImageHeight(0),
	m_ImageChannel(TEXTURE_CHANNEL_UNKNOWN),
	m_Queue(VK_NULL_HANDLE)

{
}

VStagingImageBuffer::~VStagingImageBuffer()
{
	Cleanup();
}

void VStagingImageBuffer::Initialize(VmaAllocator* allocator, uint32_t imageWidth, uint32_t imageHeight, TextureChannel imageChannel)
{
	m_pAllocator = allocator;

	// アロケーターに登録されている情報を取得
	VmaAllocatorInfo allocatorInfo;
	vmaGetAllocatorInfo(*m_pAllocator, &allocatorInfo);

	m_LogicalDevice = vk::Device(allocatorInfo.device);
	m_PhysicalDevice = vk::PhysicalDevice(allocatorInfo.physicalDevice);
	m_ImageWidth = imageWidth;
	m_ImageHeight = imageHeight;
	m_ImageChannel = imageChannel;

	// 画像のデータサイズ
	vk::DeviceSize dataSize = imageWidth * imageHeight * imageChannel;

	// 転送用キューの取得
	QueueFamilySelector queueFamily;
	queueFamily.Initialize(m_PhysicalDevice);
	m_CommandPool = CreateCommandPool(m_LogicalDevice, queueFamily.GetTransferIndex());
	m_CommandBuffer = CreateCommandBuffer(m_LogicalDevice, m_CommandPool);
	m_Queue = m_LogicalDevice.getQueue(queueFamily.GetTransferIndex(), 0);

	auto stagingBufferInfo = CreateBufferInfo(dataSize, m_BufferUsage, m_SharingMode);


	// CPUからGPUへ情報を送るのに適したメモリ領域を作成したい
	VmaAllocationCreateInfo stagingAllocateInfo;
	stagingAllocateInfo.priority = 1.0f;
	stagingAllocateInfo.flags = m_AllocationFlag;
	stagingAllocateInfo.requiredFlags = m_RequiredFlag;
	stagingAllocateInfo.preferredFlags = m_PreferredFlag;
	stagingAllocateInfo.pool = VK_NULL_HANDLE;
	stagingAllocateInfo.memoryTypeBits = NULL;
	stagingAllocateInfo.pUserData = nullptr;
	stagingAllocateInfo.usage = VMA_MEMORY_USAGE_UNKNOWN;

	// ステージングバッファの作成
	vmaCreateBuffer(*m_pAllocator, &stagingBufferInfo, &stagingAllocateInfo, &m_Buffer, &m_Allocation, nullptr);


}

void VStagingImageBuffer::Cleanup()
{
	printf("イメージ用ステージングバッファを解放します\n");
	VBufferBase::Cleanup();
}

void VStagingImageBuffer::TransferHostDataToImageBuffer(void* transferData, vk::Image toBuffer, vk::Fence fence)
{
	if (m_pAllocator == nullptr) throw std::runtime_error("先にステージングバッファの初期化を行ってください!\n");

	//VmaAllocationInfo allocInfo;
	//vmaGetAllocationInfo(*m_pAllocator, m_Allocation, &allocInfo);

	// データを転送用バッファにコピー
	VBufferBase::MapData(m_AllocationInfo.pMappedData, transferData);

	// 転送用バッファのデータを宛先のイメージバッファにコピー
	SetCopyToImageCommand(m_CommandBuffer, m_Buffer, toBuffer, m_ImageWidth, m_ImageHeight);	// 転送コマンドを作成

	if(fence != VK_NULL_HANDLE)
	{
		m_LogicalDevice.waitForFences(fence, true, MAX_WAIT_TIME);
		m_LogicalDevice.resetFences(fence);
	}

	// コマンドバッファを実行
	vk::SubmitInfo submitInfo;
	submitInfo.commandBufferCount = 1;				// 使うコマンドは1つだけで充分
	submitInfo.pCommandBuffers = &m_CommandBuffer;	// 作成したコマンドバッファをセット

	vk::Result result = m_Queue.submit(1, &submitInfo, fence); // コマンドをGPUのキューに送信
	if (result != vk::Result::eSuccess)
	{
		throw std::runtime_error("画像のメモリ間の移動に失敗しました\n");
	}

	if (fence == VK_NULL_HANDLE)
	{
		vkQueueWaitIdle(m_Queue);
	}
	else
	{
		m_LogicalDevice.waitForFences(fence, true, MAX_WAIT_TIME); // 完了を待つ
	}

}

void VStagingImageBuffer::TransferImageBufferToHostData(VImageBufferBase* transferBuffer, Texture* toData, vk::Fence fence)
{
	// NULLチェック
	if (m_pAllocator == nullptr) throw std::runtime_error("先にステージングバッファの初期化を行ってください!");
	if(toData->pixelData.empty() == false) throw std::runtime_error("転送先は中身が空のTextureを用意してください!");

	// フェンスが設定されている場合はフェンスの処理が終わるまで待つ
	if (fence != VK_NULL_HANDLE)
	{
		m_LogicalDevice.waitForFences(fence, true, MAX_WAIT_TIME);
		m_LogicalDevice.resetFences(fence);
	}

	// 転送元の画像データを転送用バッファにコピー
	SetCopyImageToBufferCommand(					// 転送コマンドを作成
		m_CommandBuffer, 
		transferBuffer, 
		m_Buffer,
		m_ImageWidth, m_ImageHeight);
	vk::SubmitInfo submitInfo;						// コマンドを実行
	submitInfo.commandBufferCount = 1;				// 使うコマンドは1つだけで充分
	submitInfo.pCommandBuffers = &m_CommandBuffer;	// 作成したコマンドバッファをセット
	m_Queue.submit(1, &submitInfo, fence);			// コマンドをGPUのキューに送信
	
	if (fence == VK_NULL_HANDLE)
	{
		// 全てのキューの処理が完了するまで待つ
		vkQueueWaitIdle(m_Queue);
	}
	else
	{
		m_LogicalDevice.waitForFences(fence, true, MAX_WAIT_TIME); // フェンスの完了を待つ
	}


	// 転送用バッファのデータを宛先のイメージバッファにコピー
	toData->channel = m_ImageChannel;
	toData->width = m_ImageWidth;
	toData->height = m_ImageHeight;
	//toData = m_LogicalDevice.mapMemory(toData, imgMem.get(), 0, imgMemReq.size);
	toData->pixelData.resize(m_ImageWidth * m_ImageHeight * m_ImageChannel);
	VBufferBase::MapData(toData->pixelData.data(), m_AllocationInfo.pMappedData);

}

vk::CommandPool VStagingImageBuffer::CreateCommandPool(vk::Device logicalDevice, uint32_t queueFamilyIndex)
{
	// コマンドプールの作成に必要な情報を設定する
	vk::CommandPoolCreateInfo poolInfo;
	poolInfo.pNext = nullptr;
	poolInfo.queueFamilyIndex = queueFamilyIndex;
	poolInfo.flags = vk::CommandPoolCreateFlagBits::eTransient;	// コマンドバッファのリセットを許可する場合はフラグを追加する


	// グラフィックスキューファミリー用のコマンドプールを作成する
	try
	{
		return logicalDevice.createCommandPool(poolInfo);
	}
	catch (const std::exception&)
	{
		throw std::runtime_error("転送用コマンドプールの作成に失敗しました！");
	}
}

vk::CommandBuffer VStagingImageBuffer::CreateCommandBuffer(vk::Device logicalDevice, vk::CommandPool commandPool)
{
	vk::CommandBufferAllocateInfo allocInfo;
	allocInfo.commandPool = commandPool;
	allocInfo.level = vk::CommandBufferLevel::ePrimary;	// プライマリコマンドバッファ
	allocInfo.commandBufferCount = 1;					// 1つのコマンドバッファを割り当て

	try
	{
		return logicalDevice.allocateCommandBuffers(allocInfo)[0];
	}
	catch (const std::exception&)
	{
		throw std::runtime_error("転送用コマンドバッファの作成に失敗しました！");
	}

}

void VStagingImageBuffer::SetCopyToImageCommand(vk::CommandBuffer commandBuffer, vk::Buffer srcBuffer, vk::Image dstImage, uint32_t imageWidth, uint32_t imageHeight)
{
	// コマンドバッファの開始
	vk::CommandBufferBeginInfo beginInfo;
	beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;
	commandBuffer.begin(beginInfo);

	// イメージのレイアウトを変更(Undefined → TransferDstOptimal)
	vk::ImageMemoryBarrier barrier;
	barrier.oldLayout = vk::ImageLayout::eUndefined;
	barrier.newLayout = vk::ImageLayout::eTransferDstOptimal;
	barrier.image = dstImage;
	barrier.subresourceRange.aspectMask = vk::ImageAspectFlagBits::eColor;
	barrier.subresourceRange.baseMipLevel = 0;
	barrier.subresourceRange.levelCount = 1;
	barrier.subresourceRange.baseArrayLayer = 0;
	barrier.subresourceRange.layerCount = 1;
	barrier.srcAccessMask = {};
	barrier.dstAccessMask = vk::AccessFlagBits::eTransferWrite;

	commandBuffer.pipelineBarrier(vk::PipelineStageFlagBits::eTopOfPipe,
		vk::PipelineStageFlagBits::eTransfer,
		{}, {}, {}, barrier);


	// ステージングバッファからイメージへコピー
	vk::BufferImageCopy copyRegion;
	copyRegion.bufferOffset = 0;
	copyRegion.bufferRowLength = 0;			// "0"を指定しておくと自動的にExtentの値が入る
	copyRegion.bufferImageHeight = 0;		// "0"を指定しておくと自動的にExtentの値が入る
	copyRegion.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
	copyRegion.imageSubresource.mipLevel = 0;
	copyRegion.imageSubresource.baseArrayLayer = 0;
	copyRegion.imageSubresource.layerCount = 1;
	copyRegion.imageOffset = vk::Offset3D{ 0, 0, 0 };
	copyRegion.imageExtent = vk::Extent3D{ imageWidth, imageHeight, 1 };

	commandBuffer.copyBufferToImage(srcBuffer, dstImage, vk::ImageLayout::eTransferDstOptimal, { copyRegion });

	// イメージのレイアウトを変更（TransferDstOptimal → ShaderReadOnlyOptimal）
	barrier.oldLayout = vk::ImageLayout::eTransferDstOptimal;
	barrier.newLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
	barrier.srcAccessMask = vk::AccessFlagBits::eTransferWrite;
	barrier.dstAccessMask = vk::AccessFlagBits::eShaderRead;

	commandBuffer.pipelineBarrier(vk::PipelineStageFlagBits::eTransfer,
		vk::PipelineStageFlagBits::eFragmentShader,
		{}, {}, {}, barrier);

	// コマンドバッファの終了
	commandBuffer.end();
}

void VStagingImageBuffer::SetCopyImageToBufferCommand(
	vk::CommandBuffer commandBuffer, 
	VImageBufferBase* srcImage, 
	vk::Buffer dstBuffer, 
	uint32_t imageWidth, 
	uint32_t imageHeight)
{
	// コマンドバッファの開始
	vk::CommandBufferBeginInfo beginInfo;
	beginInfo.flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit;
	commandBuffer.begin(beginInfo);

	// イメージのレイアウトをTRANSFER_SRC_OPTIMALに変換
	vk::ImageMemoryBarrier barrier;
	barrier.oldLayout = vk::ImageLayout::eUndefined;
	barrier.newLayout = vk::ImageLayout::eTransferSrcOptimal;
	barrier.image = srcImage->GetImageBuffer();
	barrier.subresourceRange.aspectMask = srcImage->GetAspectFlag();
	barrier.subresourceRange.baseMipLevel = 0;
	barrier.subresourceRange.levelCount = 1;
	barrier.subresourceRange.baseArrayLayer = 0;
	barrier.subresourceRange.layerCount = 1;
	barrier.srcAccessMask = vk::AccessFlagBits::eMemoryRead;
	barrier.dstAccessMask = vk::AccessFlagBits::eTransferRead;

	commandBuffer.pipelineBarrier(vk::PipelineStageFlagBits::eTopOfPipe,
		vk::PipelineStageFlagBits::eTransfer,
		{}, {}, {}, barrier);


	// ステージングバッファからイメージへコピー
	vk::BufferImageCopy copyRegion;
	copyRegion.bufferOffset = 0;
	copyRegion.bufferRowLength = 0;			// "0"を指定しておくと自動的にExtentの値が入る
	copyRegion.bufferImageHeight = 0;		// "0"を指定しておくと自動的にExtentの値が入る
	copyRegion.imageSubresource.aspectMask = vk::ImageAspectFlagBits::eColor;
	copyRegion.imageSubresource.mipLevel = 0;
	copyRegion.imageSubresource.baseArrayLayer = 0;
	copyRegion.imageSubresource.layerCount = 1;
	copyRegion.imageOffset = vk::Offset3D{ 0, 0, 0 };
	copyRegion.imageExtent = vk::Extent3D{ imageWidth, imageHeight, 1 };

	commandBuffer.copyImageToBuffer(
		srcImage->GetImageBuffer(), vk::ImageLayout::eTransferSrcOptimal,
		dstBuffer,
		{ copyRegion });


	// レイアウトを元に戻す
	barrier.oldLayout = vk::ImageLayout::eTransferSrcOptimal;
	barrier.newLayout = vk::ImageLayout::eColorAttachmentOptimal;
	barrier.srcAccessMask = vk::AccessFlagBits::eTransferRead;
	barrier.dstAccessMask = vk::AccessFlagBits::eMemoryRead;

	commandBuffer.pipelineBarrier(
		vk::PipelineStageFlagBits::eTransfer,
		vk::PipelineStageFlagBits::eFragmentShader,
		{}, {}, {}, barrier);

	// コマンドバッファの終了
	commandBuffer.end();

}

